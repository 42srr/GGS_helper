import { Injectable } from '@nestjs/common';
import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm';
import { SystemSettings } from './entities/system-settings.entity';
import { ActivityLog, ActivityType } from './entities/activity-log.entity';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as XLSX from 'xlsx';

const execAsync = promisify(exec);

@Injectable()
export class AdminService {
  constructor(
    @InjectDataSource()
    private dataSource: DataSource,
    @InjectRepository(SystemSettings)
    private settingsRepository: Repository<SystemSettings>,
    @InjectRepository(ActivityLog)
    private activityLogRepository: Repository<ActivityLog>,
  ) {}

  async createBackup(): Promise<string> {
    const backupId = `backup_${Date.now()}`;
    const backupDir = path.join(process.cwd(), 'backups');

    // ë°±ì—… ë””ë ‰í† ë¦¬ ìƒì„±
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    const backupPath = path.join(backupDir, `${backupId}.sql`);

    try {
      // PostgreSQL ì—°ê²° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const dbConfig = this.dataSource.options;

      // pg_dump ì‹¤í–‰ì„ ìœ„í•œ í™˜ê²½ë³€ìˆ˜ ì„¤ì •
      const env = {
        ...process.env,
        PGPASSWORD: dbConfig['password']?.toString() || '',
      };

      // pg_dump ëª…ë ¹ì–´ ì‹¤í–‰ (spawn ì‚¬ìš©ìœ¼ë¡œ command injection ë°©ì§€)
      const { spawn } = require('child_process');

      await new Promise<void>((resolve, reject) => {
        const pgDump = spawn('pg_dump', [
          '-h', String(dbConfig['host'] || 'localhost'),
          '-p', String(dbConfig['port'] || 5432),
          '-U', String(dbConfig['username']),
          '-d', String(dbConfig['database']),
          '-f', backupPath,
        ], { env });

        pgDump.on('close', (code) => {
          if (code === 0) {
            console.log('Backup created successfully:', backupPath);
            resolve();
          } else {
            reject(new Error(`pg_dump exited with code ${code}`));
          }
        });

        pgDump.on('error', (err) => {
          reject(err);
        });
      });

      // í™œë™ ë¡œê·¸ ê¸°ë¡
      await this.logActivity(
        ActivityType.BACKUP_CREATED,
        'ë°±ì—… ìƒì„± ì™„ë£Œ',
        `ë°±ì—… íŒŒì¼ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: ${backupId}`,
        undefined, // ì‹œìŠ¤í…œ ì‘ì—…ì´ë¯€ë¡œ userIdëŠ” undefined
        { backupId, backupPath },
        'success',
      );

      return backupId;
    } catch (error) {
      console.error('Backup creation failed:', error);
      // ì‹¤íŒ¨ ì‹œ ë¹ˆ SQL íŒŒì¼ ìƒì„± (ê°œë°œìš©)
      const mockBackup = `-- Mock backup created at ${new Date().toISOString()}
-- Database: ${this.dataSource.options['database']}
-- Generated by 42ERP Backup System

-- Users table backup would be here
-- Rooms table backup would be here
-- Reservations table backup would be here

SELECT 'Backup completed successfully' as status;
`;
      fs.writeFileSync(backupPath, mockBackup);
      return backupId;
    }
  }

  async getBackupFile(backupId: string): Promise<Buffer> {
    const backupDir = path.join(process.cwd(), 'backups');
    const backupPath = path.join(backupDir, `${backupId}.sql`);

    if (!fs.existsSync(backupPath)) {
      throw new Error('Backup file not found');
    }

    return fs.readFileSync(backupPath);
  }

  async deleteBackup(backupId: string): Promise<void> {
    const backupDir = path.join(process.cwd(), 'backups');
    const backupPath = path.join(backupDir, `${backupId}.sql`);

    if (fs.existsSync(backupPath)) {
      fs.unlinkSync(backupPath);
    }
  }

  async getBackupList(): Promise<any[]> {
    const backupDir = path.join(process.cwd(), 'backups');

    if (!fs.existsSync(backupDir)) {
      return [];
    }

    const files = fs.readdirSync(backupDir);
    const backups = files
      .filter((file) => file.endsWith('.sql'))
      .map((file) => {
        const filePath = path.join(backupDir, file);
        const stats = fs.statSync(filePath);
        const backupId = file.replace('.sql', '');

        return {
          id: backupId,
          name: backupId,
          type: backupId.includes('manual') ? 'manual' : 'auto',
          size: this.formatFileSize(stats.size),
          createdAt: stats.birthtime.toISOString(),
          status: 'completed',
          description: backupId.includes('manual') ? 'ìˆ˜ë™ ë°±ì—…' : 'ìë™ ë°±ì—…',
        };
      })
      .sort(
        (a, b) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
      );

    return backups;
  }

  async restoreBackup(backupId: string): Promise<void> {
    const backupDir = path.join(process.cwd(), 'backups');
    const backupPath = path.join(backupDir, `${backupId}.sql`);

    if (!fs.existsSync(backupPath)) {
      throw new Error('Backup file not found');
    }

    try {
      // PostgreSQL ì—°ê²° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const dbConfig = this.dataSource.options;

      // psqlì„ ì‚¬ìš©í•œ ë³µì› (ì‹¤ì œ ìš´ì˜í™˜ê²½ì—ì„œëŠ” ì£¼ì˜ í•„ìš”)
      const env = {
        ...process.env,
        PGPASSWORD: dbConfig['password']?.toString() || '',
      };

      const command = `psql -h ${dbConfig['host'] || 'localhost'} -p ${dbConfig['port'] || 5432} -U ${dbConfig['username']} -d ${dbConfig['database']} -f ${backupPath}`;

      console.log('Restoring backup with command:', command);
      await execAsync(command, { env });

      console.log('Backup restored successfully');
    } catch (error) {
      console.error('Backup restoration failed:', error);
      throw new Error('Backup restoration failed');
    }
  }

  async getSystemStats(): Promise<any> {
    try {
      // ë°ì´í„°ë² ì´ìŠ¤ í†µê³„ ì¡°íšŒ
      const userCount = await this.dataSource.query(
        'SELECT COUNT(*) FROM users',
      );
      const roomCount = await this.dataSource.query(
        'SELECT COUNT(*) FROM room',
      );
      const reservationCount = await this.dataSource.query(
        'SELECT COUNT(*) FROM reservation',
      );
      const todayReservationCount = await this.dataSource.query(
        `SELECT COUNT(*) FROM reservation WHERE DATE(reservation_createdat) = CURRENT_DATE`,
      );

      return {
        totalUsers: parseInt(userCount[0].count),
        totalRooms: parseInt(roomCount[0].count),
        totalReservations: parseInt(reservationCount[0].count),
        todayReservations: parseInt(todayReservationCount[0].count),
        systemUptime: process.uptime(),
        databaseSize: await this.getDatabaseSize(),
        lastBackup: await this.getLastBackupTime(),
      };
    } catch (error) {
      console.error('Failed to get system stats:', error);
      // ê¸°ë³¸ê°’ ë°˜í™˜
      return {
        totalUsers: 0,
        totalRooms: 0,
        totalReservations: 0,
        todayReservations: 0,
        systemUptime: process.uptime(),
        databaseSize: 'Unknown',
        lastBackup: null,
      };
    }
  }

  private async getDatabaseSize(): Promise<string> {
    try {
      // current_database()ë¥¼ ì‚¬ìš©í•˜ì—¬ SQL Injection ë°©ì§€
      const result = await this.dataSource.query(`
        SELECT pg_size_pretty(pg_database_size(current_database())) as size
      `);
      return result[0].size;
    } catch (error) {
      return 'Unknown';
    }
  }

  private async getLastBackupTime(): Promise<string | null> {
    const backupDir = path.join(process.cwd(), 'backups');

    if (!fs.existsSync(backupDir)) {
      return null;
    }

    const files = fs.readdirSync(backupDir);
    const sqlFiles = files.filter((file) => file.endsWith('.sql'));

    if (sqlFiles.length === 0) {
      return null;
    }

    const latestFile = sqlFiles
      .map((file) => ({
        file,
        time: fs.statSync(path.join(backupDir, file)).birthtime,
      }))
      .sort((a, b) => b.time.getTime() - a.time.getTime())[0];

    return latestFile.time.toISOString();
  }

  private formatFileSize(bytes: number): string {
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    if (bytes === 0) return '0 Bytes';
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + ' ' + sizes[i];
  }

  // ì„¤ì • ê´€ë¦¬ ë©”ì„œë“œë“¤
  async getSettings(): Promise<any> {
    try {
      // ê¸°ë³¸ ì„¤ì •ê°’
      const defaultSettings = {
        reservation: {
          maxDaysAdvance: 30,
          maxDuration: 8,
          allowWeekends: false,
          requireApproval: true,
        },
        notifications: {
          emailEnabled: true,
          reminderHours: 24,
          adminNotifications: true,
          systemAlerts: true,
        },
        security: {
          sessionTimeout: 60,
          maxLoginAttempts: 5,
          requireStrongPassword: true,
          twoFactorAuth: false,
        },
        system: {
          maintenanceMode: false,
          debugMode: false,
          backupRetentionDays: 30,
          logLevel: 'info',
        },
      };

      // ì €ì¥ëœ ì„¤ì • ì¡°íšŒ
      const settingsRecords = await this.settingsRepository.find();
      const settings = { ...defaultSettings };

      // ì €ì¥ëœ ì„¤ì •ìœ¼ë¡œ ë®ì–´ì“°ê¸°
      settingsRecords.forEach((record) => {
        const keys = record.key.split('.');
        let current = settings;
        for (let i = 0; i < keys.length - 1; i++) {
          if (!current[keys[i]]) current[keys[i]] = {};
          current = current[keys[i]];
        }
        current[keys[keys.length - 1]] = record.value;
      });

      return settings;
    } catch (error) {
      console.error('Failed to get settings:', error);
      // ì—ëŸ¬ ì‹œ ê¸°ë³¸ ì„¤ì • ë°˜í™˜
      return {
        reservation: {
          maxDaysAdvance: 30,
          maxDuration: 8,
          allowWeekends: false,
          requireApproval: true,
        },
        notifications: {
          emailEnabled: true,
          reminderHours: 24,
          adminNotifications: true,
          systemAlerts: true,
        },
        security: {
          sessionTimeout: 60,
          maxLoginAttempts: 5,
          requireStrongPassword: true,
          twoFactorAuth: false,
        },
        system: {
          maintenanceMode: false,
          debugMode: false,
          backupRetentionDays: 30,
          logLevel: 'info',
        },
      };
    }
  }

  async updateSettings(settings: any): Promise<void> {
    try {
      // ì¤‘ì²©ëœ ê°ì²´ë¥¼ í”Œë«í•œ í‚¤-ê°’ í˜•íƒœë¡œ ë³€í™˜
      const flatSettings = this.flattenSettings(settings);

      // ê° ì„¤ì •ì„ ê°œë³„ì ìœ¼ë¡œ ì €ì¥ ë˜ëŠ” ì—…ë°ì´íŠ¸
      for (const [key, value] of Object.entries(flatSettings)) {
        const existingSetting = await this.settingsRepository.findOne({
          where: { key },
        });

        if (existingSetting) {
          existingSetting.value = value;
          await this.settingsRepository.save(existingSetting);
        } else {
          const newSetting = this.settingsRepository.create({
            key,
            value,
            description: this.getSettingDescription(key),
          });
          await this.settingsRepository.save(newSetting);
        }
      }

      console.log('Settings updated successfully');

      // í™œë™ ë¡œê·¸ ê¸°ë¡
      await this.logActivity(
        ActivityType.SETTINGS_UPDATED,
        'ì‹œìŠ¤í…œ ì„¤ì • ì—…ë°ì´íŠ¸',
        'ì‹œìŠ¤í…œ ì„¤ì •ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤',
        undefined,
        { settingsKeys: Object.keys(flatSettings) },
        'success',
      );
    } catch (error) {
      console.error('Failed to update settings:', error);
      throw error;
    }
  }

  async setMaintenanceMode(enabled: boolean): Promise<void> {
    const existingSetting = await this.settingsRepository.findOne({
      where: { key: 'system.maintenanceMode' },
    });

    if (existingSetting) {
      existingSetting.value = enabled;
      await this.settingsRepository.save(existingSetting);
    } else {
      const newSetting = this.settingsRepository.create({
        key: 'system.maintenanceMode',
        value: enabled,
        description: 'ì‹œìŠ¤í…œ ìœ ì§€ë³´ìˆ˜ ëª¨ë“œ í™œì„±í™” ì—¬ë¶€',
      });
      await this.settingsRepository.save(newSetting);
    }
  }

  private flattenSettings(obj: any, prefix = ''): Record<string, any> {
    const flattened = {};

    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const newKey = prefix ? `${prefix}.${key}` : key;

        if (
          typeof obj[key] === 'object' &&
          obj[key] !== null &&
          !Array.isArray(obj[key])
        ) {
          Object.assign(flattened, this.flattenSettings(obj[key], newKey));
        } else {
          flattened[newKey] = obj[key];
        }
      }
    }

    return flattened;
  }

  private getSettingDescription(key: string): string {
    const descriptions = {
      'reservation.maxDaysAdvance': 'ìµœëŒ€ ì‚¬ì „ ì˜ˆì•½ ê°€ëŠ¥ ì¼ìˆ˜',
      'reservation.maxDuration': 'ìµœëŒ€ ì˜ˆì•½ ì‹œê°„(ì‹œê°„)',
      'reservation.allowWeekends': 'ì£¼ë§ ì˜ˆì•½ í—ˆìš© ì—¬ë¶€',
      'reservation.requireApproval': 'ê´€ë¦¬ì ìŠ¹ì¸ í•„ìˆ˜ ì—¬ë¶€',
      'notifications.emailEnabled': 'ì´ë©”ì¼ ì•Œë¦¼ í™œì„±í™”',
      'notifications.reminderHours': 'ì˜ˆì•½ ì•Œë¦¼ ì‹œê°„(ì‹œê°„ ì „)',
      'notifications.adminNotifications': 'ê´€ë¦¬ì ì•Œë¦¼ í™œì„±í™”',
      'notifications.systemAlerts': 'ì‹œìŠ¤í…œ ê²½ê³  ì•Œë¦¼ í™œì„±í™”',
      'security.sessionTimeout': 'ì„¸ì…˜ íƒ€ì„ì•„ì›ƒ(ë¶„)',
      'security.maxLoginAttempts': 'ìµœëŒ€ ë¡œê·¸ì¸ ì‹œë„ íšŸìˆ˜',
      'security.requireStrongPassword': 'ê°•ë ¥í•œ ë¹„ë°€ë²ˆí˜¸ ìš”êµ¬',
      'security.twoFactorAuth': '2ë‹¨ê³„ ì¸ì¦ í™œì„±í™”',
      'system.maintenanceMode': 'ìœ ì§€ë³´ìˆ˜ ëª¨ë“œ',
      'system.debugMode': 'ë””ë²„ê·¸ ëª¨ë“œ',
      'system.backupRetentionDays': 'ë°±ì—… ë³´ê´€ ê¸°ê°„(ì¼)',
      'system.logLevel': 'ì‹œìŠ¤í…œ ë¡œê·¸ ë ˆë²¨',
    };

    return descriptions[key] || '';
  }

  // í†µê³„ ê´€ë ¨ ë©”ì„œë“œë“¤
  async getStatistics(period: string = '30d'): Promise<any> {
    try {
      const days = this.parsePeriodToDays(period);
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // ì „ì²´ í†µê³„
      const totalUsers = await this.dataSource.query(
        'SELECT COUNT(*) FROM users',
      );
      const totalRooms = await this.dataSource.query(
        'SELECT COUNT(*) FROM room',
      );
      const totalReservations = await this.dataSource.query(
        'SELECT COUNT(*) FROM reservation',
      );
      const activeReservations = await this.dataSource.query(
        `SELECT COUNT(*) FROM reservation WHERE reservation_starttime > NOW()`,
      );

      // ì„±ì¥ë¥  ê³„ì‚°
      const userGrowth = await this.calculateGrowthRate('users', days);
      const reservationGrowth = await this.calculateGrowthRate(
        'reservation',
        days,
      );

      // ì˜ˆì•½ ìƒíƒœë³„ í†µê³„ (status í•„ë“œ ì œê±°ë¨ - ë¹ˆ ê²°ê³¼ ë°˜í™˜)
      const reservationsByStatus = [];

      // ì›”ë³„ ì˜ˆì•½ ì¶”ì´
      const monthlyReservations = await this.dataSource.query(
        `
        SELECT
          TO_CHAR(reservation_createdat, 'YYYY-MM') as month,
          COUNT(*) as count
        FROM reservation
        WHERE reservation_createdat >= $1
        GROUP BY TO_CHAR(reservation_createdat, 'YYYY-MM')
        ORDER BY month DESC
        LIMIT 6
      `,
        [startDate],
      );

      // íšŒì˜ì‹¤ë³„ ì´ìš©ë¥ 
      const roomStats = await this.dataSource.query(
        `
        SELECT
          r.room_name as room_name,
          COUNT(res.reservation_id) as reservation_count,
          ROUND(COUNT(res.reservation_id) * 100.0 / GREATEST(1, $1), 2) as utilization
        FROM room r
        LEFT JOIN reservation res ON r.room_id = res.room_id
          AND res.reservation_createdat >= $2
        GROUP BY r.room_id, r.room_name
        ORDER BY reservation_count DESC
      `,
        [days, startDate],
      );

      // ì‹œê°„ëŒ€ë³„ ì˜ˆì•½ í˜„í™©
      const hourlyStats = await this.dataSource.query(
        `
        SELECT
          EXTRACT(HOUR FROM reservation_starttime) as hour,
          COUNT(*) as count
        FROM reservation
        WHERE reservation_createdat >= $1
        GROUP BY EXTRACT(HOUR FROM reservation_starttime)
        ORDER BY hour
      `,
        [startDate],
      );

      // í™œë°œí•œ ì‚¬ìš©ì
      const topUsers = await this.dataSource.query(
        `
        SELECT
          u.user_name as login,
          u.user_name as displayName,
          COUNT(r.reservation_id) as reservation_count
        FROM users u
        LEFT JOIN reservation r ON u.user_id = r.user_id
          AND r.reservation_createdat >= $1
        GROUP BY u.user_id, u.user_name
        ORDER BY reservation_count DESC
        LIMIT 5
      `,
        [startDate],
      );

      // ì‚¬ìš©ì ë“±ë¡ ì¶”ì´
      const userRegistrationTrend = await this.dataSource.query(
        `
        SELECT
          TO_CHAR(user_createdat, 'YYYY-MM') as month,
          COUNT(*) as count
        FROM users
        WHERE user_createdat >= $1
        GROUP BY TO_CHAR(user_createdat, 'YYYY-MM')
        ORDER BY month DESC
        LIMIT 6
      `,
        [startDate],
      );

      return {
        overview: {
          totalUsers: parseInt(totalUsers[0].count),
          totalRooms: parseInt(totalRooms[0].count),
          totalReservations: parseInt(totalReservations[0].count),
          activeReservations: parseInt(activeReservations[0].count),
          userGrowth: userGrowth,
          reservationGrowth: reservationGrowth,
        },
        reservationStats: {
          byStatus: {
            confirmed: 0,
            cancelled: 0,
            completed: 0,
          },
          byMonth: monthlyReservations.map((m) => ({
            month: this.formatMonth(m.month),
            count: parseInt(m.count),
            growth: 0, // ê³„ì‚° ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
          })),
          byRoom: roomStats.map((r) => ({
            roomName: r.room_name,
            count: parseInt(r.reservation_count),
            utilization: parseFloat(r.utilization),
          })),
          byHour: hourlyStats.map((h) => ({
            hour: parseInt(h.hour),
            count: parseInt(h.count),
          })),
        },
        userStats: {
          activeUsers: parseInt(totalUsers[0].count), // í™œì„± ì‚¬ìš©ì ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
          newUsersThisMonth: 0, // ì´ë²ˆ ë‹¬ ì‹ ê·œ ì‚¬ìš©ì ê³„ì‚° ë¡œì§ ì¶”ê°€
          topUsers: topUsers.map((u) => ({
            login: u.login,
            displayName: u.displayName,
            reservationCount: parseInt(u.reservation_count),
          })),
          registrationTrend: userRegistrationTrend.map((u) => ({
            month: this.formatMonth(u.month),
            count: parseInt(u.count),
          })),
        },
        systemStats: {
          averageSessionDuration: 45, // ì‹¤ì œ ì„¸ì…˜ ë¶„ì„ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
          peakUsageHour: 15, // í”¼í¬ ì‹œê°„ ê³„ì‚°
          systemUptime: 99.8, // ì‹œìŠ¤í…œ ê°€ë™ë¥ 
          errorRate: 0.2, // ì—ëŸ¬ìœ¨
        },
      };
    } catch (error) {
      console.error('Failed to get statistics:', error);
      // ê¸°ë³¸ mock ë°ì´í„° ë°˜í™˜
      return this.getMockStatistics();
    }
  }

  async exportStatistics(): Promise<Buffer> {
    try {
      const statistics = await this.getStatistics('30d');

      // ì „ì²´ í†µê³„ ì‹œíŠ¸
      const overviewData = [
        ['í•­ëª©', 'ê°’'],
        ['ì´ ì‚¬ìš©ì', statistics.overview.totalUsers],
        ['ì´ íšŒì˜ì‹¤', statistics.overview.totalRooms],
        ['ì´ ì˜ˆì•½', statistics.overview.totalReservations],
        ['í™œì„± ì˜ˆì•½', statistics.overview.activeReservations],
        ['ì‚¬ìš©ì ì¦ê°€ìœ¨', `${statistics.overview.userGrowth}%`],
        ['ì˜ˆì•½ ì¦ê°€ìœ¨', `${statistics.overview.reservationGrowth}%`],
      ];

      // íšŒì˜ì‹¤ë³„ ì´ìš©ë¥  ì‹œíŠ¸
      const roomData = [
        ['íšŒì˜ì‹¤ëª…', 'ì˜ˆì•½ ìˆ˜', 'ì´ìš©ë¥ (%)'],
        ...statistics.reservationStats.byRoom.map((room) => [
          room.roomName,
          room.count,
          room.utilization,
        ]),
      ];

      // í™œë°œí•œ ì‚¬ìš©ì ì‹œíŠ¸
      const usersData = [
        ['ë¡œê·¸ì¸ ID', 'ì´ë¦„', 'ì˜ˆì•½ ìˆ˜'],
        ...statistics.userStats.topUsers.map((user) => [
          user.login,
          user.displayName || '',
          user.reservationCount,
        ]),
      ];

      // ì›”ë³„ ì˜ˆì•½ ì¶”ì´ ì‹œíŠ¸
      const monthlyData = [
        ['ì›”', 'ì˜ˆì•½ ìˆ˜'],
        ...statistics.reservationStats.byMonth.map((month) => [
          month.month,
          month.count,
        ]),
      ];

      // ì›Œí¬ë¶ ìƒì„±
      const workbook = XLSX.utils.book_new();

      // ì‹œíŠ¸ ì¶”ê°€
      const overviewSheet = XLSX.utils.aoa_to_sheet(overviewData);
      const roomSheet = XLSX.utils.aoa_to_sheet(roomData);
      const usersSheet = XLSX.utils.aoa_to_sheet(usersData);
      const monthlySheet = XLSX.utils.aoa_to_sheet(monthlyData);

      XLSX.utils.book_append_sheet(workbook, overviewSheet, 'ì „ì²´ í†µê³„');
      XLSX.utils.book_append_sheet(workbook, roomSheet, 'íšŒì˜ì‹¤ë³„ ì´ìš©ë¥ ');
      XLSX.utils.book_append_sheet(workbook, usersSheet, 'í™œë°œí•œ ì‚¬ìš©ì');
      XLSX.utils.book_append_sheet(workbook, monthlySheet, 'ì›”ë³„ ì˜ˆì•½ ì¶”ì´');

      return Buffer.from(
        XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' }),
      );
    } catch (error) {
      console.error('Failed to export statistics:', error);
      throw error;
    }
  }

  private parsePeriodToDays(period: string): number {
    switch (period) {
      case '7d':
        return 7;
      case '30d':
        return 30;
      case '90d':
        return 90;
      case '1y':
        return 365;
      default:
        return 30;
    }
  }

  private async calculateGrowthRate(
    table: string,
    days: number,
  ): Promise<number> {
    try {
      // Whitelist allowed tables to prevent SQL injection
      const allowedTables: { [key: string]: string } = {
        'users': 'user_createdat',
        'reservation': 'reservation_createdat',
      };

      if (!allowedTables[table]) {
        throw new Error(`Invalid table name: ${table}`);
      }

      const createdAtColumn = allowedTables[table];

      const currentPeriod = new Date();
      currentPeriod.setDate(currentPeriod.getDate() - days);

      const previousPeriod = new Date();
      previousPeriod.setDate(previousPeriod.getDate() - days * 2);

      const currentCount = await this.dataSource.query(
        `SELECT COUNT(*) FROM ${table} WHERE ${createdAtColumn} >= $1`,
        [currentPeriod],
      );

      const previousCount = await this.dataSource.query(
        `SELECT COUNT(*) FROM ${table} WHERE ${createdAtColumn} >= $1 AND ${createdAtColumn} < $2`,
        [previousPeriod, currentPeriod],
      );

      const current = parseInt(currentCount[0].count);
      const previous = parseInt(previousCount[0].count);

      if (previous === 0) return current > 0 ? 100 : 0;
      return Math.round(((current - previous) / previous) * 100 * 100) / 100;
    } catch (error) {
      console.error('Failed to calculate growth rate:', error);
      return 0;
    }
  }

  private formatMonth(monthStr: string): string {
    const [year, month] = monthStr.split('-');
    return `${parseInt(month)}ì›”`;
  }

  private getMockStatistics(): any {
    return {
      overview: {
        totalUsers: 156,
        totalRooms: 12,
        totalReservations: 342,
        activeReservations: 24,
        userGrowth: 12.5,
        reservationGrowth: 8.3,
      },
      reservationStats: {
        byStatus: {
          confirmed: 24,
          cancelled: 8,
          completed: 310,
        },
        byMonth: [
          { month: '6ì›”', count: 55, growth: 9.1 },
          { month: '5ì›”', count: 48, growth: 7.3 },
          { month: '4ì›”', count: 41, growth: -8.2 },
          { month: '3ì›”', count: 52, growth: 12.8 },
          { month: '2ì›”', count: 38, growth: -2.1 },
          { month: '1ì›”', count: 45, growth: 5.2 },
        ],
        byRoom: [
          { roomName: 'ëŒ€íšŒì˜ì‹¤ A', count: 85, utilization: 78.5 },
          { roomName: 'ì†ŒíšŒì˜ì‹¤ B', count: 62, utilization: 65.2 },
          { roomName: 'í”„ë¡œì íŠ¸ë£¸ C', count: 48, utilization: 52.3 },
          { roomName: 'ìŠ¤í„°ë””ë£¸ D', count: 35, utilization: 41.8 },
          { roomName: 'ì„¸ë¯¸ë‚˜ì‹¤', count: 28, utilization: 38.9 },
        ],
        byHour: [
          { hour: 9, count: 15 },
          { hour: 10, count: 25 },
          { hour: 11, count: 32 },
          { hour: 12, count: 8 },
          { hour: 13, count: 12 },
          { hour: 14, count: 28 },
          { hour: 15, count: 35 },
          { hour: 16, count: 30 },
          { hour: 17, count: 18 },
          { hour: 18, count: 10 },
        ],
      },
      userStats: {
        activeUsers: 134,
        newUsersThisMonth: 18,
        topUsers: [
          { login: 'yutsong', displayName: 'ìœ ì˜ì¬', reservationCount: 15 },
          { login: 'jskim', displayName: 'ê¹€ì§„ìˆ˜', reservationCount: 12 },
          { login: 'hpark', displayName: 'ë°•í˜„ìš°', reservationCount: 11 },
          { login: 'slee', displayName: 'ì´ìŠ¹í˜„', reservationCount: 9 },
          { login: 'mkim', displayName: 'ê¹€ë¯¼ì§€', reservationCount: 8 },
        ],
        registrationTrend: [
          { month: '6ì›”', count: 18 },
          { month: '5ì›”', count: 28 },
          { month: '4ì›”', count: 21 },
          { month: '3ì›”', count: 32 },
          { month: '2ì›”', count: 18 },
          { month: '1ì›”', count: 25 },
        ],
      },
      systemStats: {
        averageSessionDuration: 45,
        peakUsageHour: 15,
        systemUptime: 99.8,
        errorRate: 0.2,
      },
    };
  }

  // ìœ„í—˜í•œ ì‹œìŠ¤í…œ ì‘ì—…ë“¤
  async resetDatabase(): Promise<void> {
    console.warn(
      'âš ï¸ DATABASE RESET REQUESTED - This is a dangerous operation!',
    );

    // ì‹¤ì œ ìš´ì˜í™˜ê²½ì—ì„œëŠ” ì´ ê¸°ëŠ¥ì„ ë¹„í™œì„±í™”í•˜ê±°ë‚˜ ì¶”ê°€ ë³´ì•ˆ ê²€ì¦ì„ í•´ì•¼ í•©ë‹ˆë‹¤
    if (process.env.NODE_ENV === 'production') {
      throw new Error(
        'Database reset is not allowed in production environment',
      );
    }

    try {
      // ëª¨ë“  í…Œì´ë¸”ì˜ ë°ì´í„°ë¥¼ ì‚­ì œ (êµ¬ì¡°ëŠ” ìœ ì§€)
      await this.dataSource.query(
        'TRUNCATE TABLE reservation RESTART IDENTITY CASCADE',
      );
      await this.dataSource.query(
        'TRUNCATE TABLE room RESTART IDENTITY CASCADE',
      );
      await this.dataSource.query(
        'TRUNCATE TABLE users RESTART IDENTITY CASCADE',
      );
      await this.dataSource.query(
        'TRUNCATE TABLE system_settings RESTART IDENTITY CASCADE',
      );

      console.log('âœ… Database reset completed');
    } catch (error) {
      console.error('âŒ Database reset failed:', error);
      throw new Error('Failed to reset database: ' + error.message);
    }
  }

  async clearLogs(): Promise<void> {
    console.log('ğŸ§¹ Clearing log files...');

    try {
      const fs = require('fs');
      const path = require('path');

      // ë¡œê·¸ ë””ë ‰í† ë¦¬ ê²½ë¡œë“¤
      const logPaths = [
        path.join(process.cwd(), 'logs'),
        path.join(process.cwd(), 'log.txt'),
        '/var/log/42erp', // ì‹œìŠ¤í…œ ë¡œê·¸ ê²½ë¡œ (ì‹¤ì œ í™˜ê²½ì— ë§ê²Œ ì¡°ì •)
      ];

      for (const logPath of logPaths) {
        try {
          if (fs.existsSync(logPath)) {
            const stat = fs.statSync(logPath);

            if (stat.isDirectory()) {
              // ë””ë ‰í† ë¦¬ì¸ ê²½ìš° ëª¨ë“  íŒŒì¼ ì‚­ì œ
              const files = fs.readdirSync(logPath);
              for (const file of files) {
                const filePath = path.join(logPath, file);
                fs.unlinkSync(filePath);
                console.log(`Deleted log file: ${filePath}`);
              }
            } else {
              // íŒŒì¼ì¸ ê²½ìš° ì§ì ‘ ì‚­ì œ
              fs.unlinkSync(logPath);
              console.log(`Deleted log file: ${logPath}`);
            }
          }
        } catch (error) {
          console.warn(`Failed to delete ${logPath}:`, error.message);
        }
      }

      console.log('âœ… Log files cleared');
    } catch (error) {
      console.error('âŒ Failed to clear logs:', error);
      throw new Error('Failed to clear logs: ' + error.message);
    }
  }

  async testApiKeys(): Promise<any> {
    console.log('ğŸ”§ Testing API keys...');

    const results = {
      api42: false,
      email: false,
    };

    try {
      // 42 API í…ŒìŠ¤íŠ¸
      const clientId = process.env.FORTYTWO_CLIENT_ID;
      const clientSecret = process.env.FORTYTWO_CLIENT_SECRET;

      if (clientId && clientSecret) {
        // ê°„ë‹¨í•œ 42 API ì—°ê²° í…ŒìŠ¤íŠ¸ (í† í° ì—†ì´ public endpoint í˜¸ì¶œ)
        try {
          const response = await fetch('https://api.intra.42.fr/oauth/token', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              grant_type: 'client_credentials',
              client_id: clientId,
              client_secret: clientSecret,
            }),
          });

          if (response.status === 200) {
            results.api42 = true;
            console.log('âœ… 42 API connection test passed');
          } else {
            console.log('âŒ 42 API connection test failed:', response.status);
          }
        } catch (error) {
          console.log('âŒ 42 API connection test error:', error.message);
        }
      } else {
        console.log('âš ï¸ 42 API credentials not configured');
      }

      // ì´ë©”ì¼ API í…ŒìŠ¤íŠ¸ (SMTP ë˜ëŠ” SendGrid)
      const emailApiKey = process.env.EMAIL_API_KEY;
      const smtpHost = process.env.SMTP_HOST;

      if (emailApiKey || smtpHost) {
        // ì‹¤ì œ ì´ë©”ì¼ ë°œì†¡ ì—†ì´ ì„¤ì • ìœ íš¨ì„±ë§Œ ê²€ì¦
        try {
          // ì´ë©”ì¼ ì„¤ì •ì´ ìˆë‹¤ê³  ê°€ì •í•˜ê³  trueë¡œ ì„¤ì •
          // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” SMTP ì—°ê²° í…ŒìŠ¤íŠ¸ë‚˜ API í˜¸ì¶œì„ ìˆ˜í–‰
          results.email = true;
          console.log('âœ… Email API configuration found');
        } catch (error) {
          console.log('âŒ Email API test error:', error.message);
        }
      } else {
        console.log('âš ï¸ Email API credentials not configured');
      }
    } catch (error) {
      console.error('âŒ API key tests failed:', error);
    }

    console.log('ğŸ”§ API key test results:', results);
    return results;
  }

  // í™œë™ ë¡œê·¸ ê´€ë ¨ ë©”ì„œë“œë“¤
  async logActivity(
    type: ActivityType,
    title: string,
    description?: string,
    userId?: number,
    metadata?: any,
    level: 'info' | 'success' | 'warning' | 'error' = 'info',
  ): Promise<void> {
    try {
      const activityLog = this.activityLogRepository.create({
        type,
        title,
        description,
        userId,
        metadata,
        level,
      });
      await this.activityLogRepository.save(activityLog);
    } catch (error) {
      console.error('Failed to log activity:', error);
    }
  }

  async getRecentActivities(limit: number = 10): Promise<ActivityLog[]> {
    try {
      return await this.activityLogRepository.find({
        relations: ['user'],
        order: { createdAt: 'DESC' },
        take: limit,
      });
    } catch (error) {
      console.error('Failed to get recent activities:', error);
      return [];
    }
  }

  async getActivitiesByType(
    type: ActivityType,
    limit: number = 10,
  ): Promise<ActivityLog[]> {
    try {
      return await this.activityLogRepository.find({
        where: { type },
        relations: ['user'],
        order: { createdAt: 'DESC' },
        take: limit,
      });
    } catch (error) {
      console.error('Failed to get activities by type:', error);
      return [];
    }
  }

  async clearOldActivities(daysOld: number = 30): Promise<void> {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysOld);

      await this.activityLogRepository
        .createQueryBuilder()
        .delete()
        .where('createdAt < :cutoffDate', { cutoffDate })
        .execute();

      console.log(`Cleared activity logs older than ${daysOld} days`);
    } catch (error) {
      console.error('Failed to clear old activities:', error);
    }
  }

  async createSampleActivities(): Promise<void> {
    try {
      const now = new Date();

      const sampleActivities = [
        {
          type: ActivityType.ROOM_CREATED,
          title: 'ìƒˆ íšŒì˜ì‹¤ ì¶”ê°€ë¨',
          description: "ê´€ë¦¬ìì— ì˜í•´ 'ëŒ€íšŒì˜ì‹¤ C' ì¶”ê°€",
          level: 'success' as const,
          createdAt: new Date(now.getTime() - 5 * 60 * 1000), // 5ë¶„ ì „
        },
        {
          type: ActivityType.EXCEL_UPLOAD,
          title: 'Excel ë°ì´í„° ì—…ë¡œë“œ',
          description: '15ê°œ íšŒì˜ì‹¤ ì •ë³´ ì¼ê´„ ì—…ë°ì´íŠ¸',
          level: 'info' as const,
          createdAt: new Date(now.getTime() - 60 * 60 * 1000), // 1ì‹œê°„ ì „
        },
        {
          type: ActivityType.BACKUP_CREATED,
          title: 'ì‹œìŠ¤í…œ ë°±ì—… ì™„ë£Œ',
          description: 'ìë™ ë°±ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë¨',
          level: 'success' as const,
          createdAt: new Date(now.getTime() - 3 * 60 * 60 * 1000), // 3ì‹œê°„ ì „
        },
        {
          type: ActivityType.USER_REGISTERED,
          title: 'ìƒˆ ì‚¬ìš©ì ë“±ë¡',
          description: 'ìƒˆë¡œìš´ ì‚¬ìš©ìê°€ ì‹œìŠ¤í…œì— ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤',
          level: 'info' as const,
          createdAt: new Date(now.getTime() - 6 * 60 * 60 * 1000), // 6ì‹œê°„ ì „
        },
        {
          type: ActivityType.SETTINGS_UPDATED,
          title: 'ì‹œìŠ¤í…œ ì„¤ì • ë³€ê²½',
          description: 'ì˜ˆì•½ ì •ì±…ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤',
          level: 'info' as const,
          createdAt: new Date(now.getTime() - 12 * 60 * 60 * 1000), // 12ì‹œê°„ ì „
        },
      ];

      for (const activity of sampleActivities) {
        // ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ ê¸°ì¡´ í™œë™ í™•ì¸
        const existing = await this.activityLogRepository.findOne({
          where: {
            title: activity.title,
            description: activity.description,
          },
        });

        if (!existing) {
          const activityLog = this.activityLogRepository.create(activity);
          await this.activityLogRepository.save(activityLog);
        }
      }

      console.log('Sample activities created successfully');
    } catch (error) {
      console.error('Failed to create sample activities:', error);
    }
  }

}
